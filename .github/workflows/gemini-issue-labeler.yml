name: Gemini Issue Labeler

on:
  issues

jobs:
  label-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read # Needed to read workflow file
    steps:
      - name: Label issue with Gemini
        uses: actions/github-script@v7
        with:
          script: |
            const https = require('https');

            async function getSuggestions() {
              const issueTitle = context.payload.issue.title;
              const issueBody = context.payload.issue.body;
              const availableLabels = "bug,feature,documentation,question,enhancement,help wanted";

              // New, more detailed prompt
              const prompt = `Analyze the following GitHub issue. Provide your response in a structured format with two sections separated by '###': LABELS and COMMENT.\n\n### LABELS\nSuggest up to 3 relevant labels from the available list, comma-separated. Available labels: ${availableLabels}\n\n### COMMENT\nSummarize the issue in one sentence. Then, based on the issue description, suggest up to 3 potentially relevant files to investigate from the project structure. Add a brief explanation for each file suggestion.\n\n---\n\nIssue Title: ${issueTitle}\n\nIssue Body:\n${issueBody}`;
              
              const apiKey = process.env.GEMINI_API_KEY;
              if (!apiKey) {
                core.setFailed("GEMINI_API_KEY secret is not set.");
                return null;
              }

              const data = JSON.stringify({
                contents: [{ 
                  parts: [{ text: prompt }]
                }]
              });

              const options = {
                hostname: 'generativelanguage.googleapis.com',
                path: `/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`,
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              };

              return new Promise((resolve, reject) => {
                const req = https.request(options, (res) => {
                  let responseBody = '';
                  res.on('data', (chunk) => { responseBody += chunk; });
                  res.on('end', () => {
                    try {
                      if (res.statusCode !== 200) {
                        return reject(new Error(`API request failed with status ${res.statusCode}: ${responseBody}`));
                      }
                      const response = JSON.parse(responseBody);
                      if (response.candidates && response.candidates[0].content.parts[0].text) {
                        resolve(response.candidates[0].content.parts[0].text);
                      } else {
                        core.warning(`Unexpected Gemini API response: ${responseBody}`);
                        resolve('');
                      }
                    } catch (e) {
                      reject(new Error(`Failed to parse Gemini API response: ${e.message}`));
                    }
                  });
                });
                req.on('error', (e) => reject(new Error(`API request failed: ${e.message}`)));
                req.write(data);
                req.end();
              });
            }

            try {
              const geminiResponse = await getSuggestions();
              if (geminiResponse) {
                const parts = geminiResponse.split('###');
                const labelsPart = parts.find(p => p.trim().startsWith('LABELS'))?.replace('LABELS', '').trim();
                const commentPart = parts.find(p => p.trim().startsWith('COMMENT'))?.replace('COMMENT', '').trim();

                if (labelsPart) {
                  const labelsToAdd = labelsPart.split(',').map(l => l.trim()).filter(Boolean);
                  if (labelsToAdd.length > 0) {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: context.issue.number,
                      labels: labelsToAdd
                    });
                    core.info(`Added labels: ${labelsToAdd.join(', ')}`);
                  }
                }

                if (commentPart) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: `**Gemini Suggestions**\n\n${commentPart}`
                  });
                  core.info("Added comment with suggestions.");
                }
              }
            } catch (error) {
              core.setFailed(`Action failed: ${error.message}`);
            }
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}