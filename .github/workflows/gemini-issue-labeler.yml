name: Gemini Issue Labeler

on:
  issues

jobs:
  label-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read # Needed to read workflow file
    steps:
      - name: Label issue with Gemini
        uses: actions/github-script@v7
        with:
          script: |
            const https = require('https');

            async function getSuggestedLabels() {
              const issueTitle = context.payload.issue.title;
              const issueBody = context.payload.issue.body;
              const availableLabels = "bug,feature,documentation,question,enhancement,help wanted";

              const prompt = `Read the following GitHub issue and suggest up to 3 relevant labels from the available list. Only return a comma-separated list of the most appropriate labels. Do not add any other text or explanation.\n\nAvailable Labels: ${availableLabels}\n\nIssue Title: ${issueTitle}\n\nIssue Body: \n${issueBody}`;
              
              const apiKey = process.env.GEMINI_API_KEY;
              if (!apiKey) {
                core.setFailed("GEMINI_API_KEY secret is not set.");
                return null;
              }

              const data = JSON.stringify({
                contents: [{ 
                  parts: [{ text: prompt }]
                }]
              });

              const options = {
                hostname: 'generativelanguage.googleapis.com',
                path: `/v1beta/models/gemini-pro:generateContent?key=${apiKey}`,
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              };

              return new Promise((resolve, reject) => {
                const req = https.request(options, (res) => {
                  let responseBody = '';
                  res.on('data', (chunk) => { responseBody += chunk; });
                  res.on('end', () => {
                    try {
                      if (res.statusCode !== 200) {
                        return reject(new Error(`API request failed with status ${res.statusCode}: ${responseBody}`));
                      }
                      const response = JSON.parse(responseBody);
                      if (response.candidates && response.candidates[0].content.parts[0].text) {
                        resolve(response.candidates[0].content.parts[0].text);
                      } else {
                        core.warning(`Unexpected Gemini API response: ${responseBody}`);
                        resolve(''); // Resolve with empty string if no labels
                      }
                    } catch (e) {
                      reject(new Error(`Failed to parse Gemini API response: ${e.message}`));
                    }
                  });
                });
                req.on('error', (e) => reject(new Error(`API request failed: ${e.message}`)));
                req.write(data);
                req.end();
              });
            }

            try {
              const suggestedLabelsText = await getSuggestedLabels();
              if (suggestedLabelsText) {
                const labelsToAdd = suggestedLabelsText.split(',').map(l => l.trim()).filter(Boolean);

                if (labelsToAdd.length > 0) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    labels: labelsToAdd
                  });
                  core.info(`Added labels: ${labelsToAdd.join(', ')}`);
                } else {
                  core.info("Gemini did not suggest any valid labels.");
                }
              }
            } catch (error) {
              core.setFailed(`Action failed: ${error.message}`);
            }
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}